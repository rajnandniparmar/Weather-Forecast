# -*- coding: utf-8 -*-
"""All_Models.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vg8xl9O_sm-RyoNmmF100zGTu3pUv2v-
"""

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.ar_model import AutoReg
from sklearn.metrics import mean_squared_error
from math import sqrt

# Load your data
df = pd.read_excel('data11.xlsx', index_col='Date')

# Ensure datetime index
df.index = pd.to_datetime(df.index)

# Display the first few rows of the DataFrame
print(df.head())

# Split the data into train and test sets (80:20)
train_size = int(len(df) * 0.8)
train_data, test_data = df.iloc[:train_size], df.iloc[train_size:]

# Check the shape of train and test sets
print("Train data shape:", train_data.shape)
print("Test data shape:", test_data.shape)

# Define the lag order (number of past observations to consider)
lag = 2  # Adjust this value based on your data and desired model complexity

# Fit Autoregressive (AR) model
model = AutoReg(train_data['BASEL_temp_mean'], lags=lag)
model_fit = model.fit()

# Display model summary
print(model_fit.summary())

# Make predictions on the test set
predictions = model_fit.predict(start=len(train_data), end=len(train_data) + len(test_data) - 1, dynamic=False)

# Calculate RMSE (Root Mean Squared Error)
rmse = sqrt(mean_squared_error(test_data['BASEL_temp_mean'], predictions))
print("Root Mean Squared Error (RMSE):", rmse)

# Plot actual vs. predicted values
plt.figure(figsize=(12, 6))
plt.plot(test_data.index, test_data['BASEL_temp_mean'], label='Actual', color='blue')
plt.plot(test_data.index, predictions, label='Predicted', color='red', linestyle='--')
plt.title('AR Model Forecast - Actual vs. Predicted')
plt.xlabel('Date')
plt.ylabel('Temperature')
plt.legend()
plt.show()

# Define the order of the Moving Average (MA) model (e.g., MA(q) with q=1)
q = 2  # Adjust this value based on your data and desired model complexity
from statsmodels.tsa.arima.model import ARIMA
# Fit Moving Average (MA) model
model = ARIMA(train_data['BASEL_temp_mean'], order=(0, 0, q))
model_fit = model.fit()

# Display model summary
print(model_fit.summary())

# Make predictions on the test set
predictions = model_fit.forecast(steps=len(test_data))

# Calculate RMSE (Root Mean Squared Error)
rmse = sqrt(mean_squared_error(test_data['BASEL_temp_mean'], predictions))
print("Root Mean Squared Error (RMSE):", rmse)

# Plot actual vs. predicted values
plt.figure(figsize=(12, 6))
plt.plot(test_data.index, test_data['BASEL_temp_mean'], label='Actual', color='blue')
plt.plot(test_data.index, predictions, label='Predicted', color='red', linestyle='--')
plt.title('Moving Average (MA) Model Forecast - Actual vs. Predicted')
plt.xlabel('Date')
plt.ylabel('Temperature')
plt.legend()
plt.show()# Make predictions on the test set
predictions = model_fit.forecast(steps=len(test_data))

# Calculate RMSE (Root Mean Squared Error)
rmse = sqrt(mean_squared_error(test_data['BASEL_temp_mean'], predictions))
print("Root Mean Squared Error (RMSE):", rmse)

# Plot actual vs. predicted values
plt.figure(figsize=(12, 6))
plt.plot(test_data.index, test_data['BASEL_temp_mean'], label='Actual', color='blue')
plt.plot(test_data.index, predictions, label='Predicted', color='red', linestyle='--')
plt.title('Moving Average (MA) Model Forecast - Actual vs. Predicted')
plt.xlabel('Date')
plt.ylabel('Temperature')
plt.legend()
plt.show()

model = ARIMA(train_data['BASEL_temp_mean'], order=(1, 0, 3))
model_fit = model.fit()
# Display model summary
print(model_fit.summary())

# Make predictions on the test set
predictions = model_fit.forecast(steps=len(test_data))

# Calculate RMSE (Root Mean Squared Error)
rmse = sqrt(mean_squared_error(test_data['BASEL_temp_mean'], predictions))
print("Root Mean Squared Error (RMSE):", rmse)

# Plot actual vs. predicted values
plt.figure(figsize=(12, 6))
plt.plot(test_data.index, test_data['BASEL_temp_mean'], label='Actual', color='blue')
plt.plot(test_data.index, predictions, label='Predicted', color='red', linestyle='--')
plt.title('ARIMA Model Forecast - Actual vs. Predicted')
plt.xlabel('Date')
plt.ylabel('Temperature')
plt.legend()
plt.show()

from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Plot ACF and PACF to determine parameters for SARIMAX
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))
plot_acf(df['BASEL_temp_mean'], lags=150, ax=ax1)
plot_pacf(df['BASEL_temp_mean'], lags=150, ax=ax2)
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error


# Split data into train and test sets (80% train, 20% test)
train_size = int(len(df) * 0.8)
train_data = df.iloc[:train_size]
test_data = df.iloc[train_size:]

# Define SARIMAX model parameters (example values, adjust as needed)
order = (2, 0, 1)             # (p, d, q) for non-seasonal components
seasonal_order = (2, 0, 1, 12) # (P, D, Q, seasonal_period) for seasonal components

# Fit SARIMAX model to the training data
model = SARIMAX(train_data['BASEL_temp_mean'], order=order, seasonal_order=seasonal_order)
results = model.fit()

# Forecast on the test data
forecast = results.get_forecast(steps=len(test_data))

# Extract forecasted values and confidence intervals
forecast_values = forecast.predicted_mean
confidence_intervals = forecast.conf_int()

# Plot actual vs. forecasted values
plt.figure(figsize=(12, 6))
plt.plot(df.index, df['BASEL_temp_mean'], label='Actual', color='blue')
plt.plot(test_data.index, forecast_values, label='Forecast', color='red')
plt.fill_between(test_data.index, confidence_intervals['lower BASEL_temp_mean'], confidence_intervals['upper BASEL_temp_mean'], color='pink', alpha=0.3, label='Confidence Interval')
plt.title('SARIMAX Forecast')
plt.xlabel('Date')
plt.ylabel('Temperature')
plt.legend()
plt.show()

# Calculate RMSE for the forecast
actual_values = test_data['BASEL_temp_mean']
rmse = np.sqrt(mean_squared_error(actual_values, forecast_values))
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

# Load your dataset (assuming 'data11.xlsx' contains your temperature data)
df = pd.read_excel('data11.xlsx', parse_dates=['Date'], index_col='Date')

# Split data into training (80%) and testing (20%) sets
train_size = int(len(df) * 0.8)
train_data = df.iloc[:train_size]
test_data = df.iloc[train_size:]

# Function to create lagged features for time series data
def create_lagged_features(data, lag=12):
    """
    Create lagged features (X) and target (y) for linear regression modeling.
    """
    lagged_data = data.copy()
    for i in range(1, lag+1):
        lagged_data[f't-{i}'] = data['BASEL_temp_mean'].shift(i)
    lagged_data.dropna(inplace=True)
    return lagged_data

# Define the number of lagged features (adjust as needed)
lag = 12

# Create lagged features and target for training data
lagged_train_data = create_lagged_features(train_data, lag=lag)
X_train = lagged_train_data.drop('BASEL_temp_mean', axis=1)
y_train = lagged_train_data['BASEL_temp_mean']

# Create lagged features and target for testing data
lagged_test_data = create_lagged_features(test_data, lag=lag)
X_test = lagged_test_data.drop('BASEL_temp_mean', axis=1)
y_test = lagged_test_data['BASEL_temp_mean']

# Fit linear regression model using the training data
model = LinearRegression()
model.fit(X_train, y_train)

# Forecast future values using the trained linear regression model
forecast_values = model.predict(X_test)

# Calculate RMSE for the forecast
rmse = np.sqrt(mean_squared_error(y_test, forecast_values))
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")

# Plotting actual vs. forecasted values
plt.figure(figsize=(12, 6))
plt.plot(test_data, label='Historical Data', color='blue')

# Ensure forecast_values aligns with test_data.index
forecast_dates = lagged_test_data.index  # Use index of lagged_test_data
plt.plot(forecast_dates, forecast_values[:len(forecast_dates)], label='Forecast', color='red', linestyle='--')

plt.title('Linear Regression Forecast - Actual vs. Forecasted Temperature')
plt.xlabel('Date')
plt.ylabel('Temperature')
plt.legend()
plt.show()